.PAG 'PET RESIDENT MONITOR'
	*=LASTWR        ;START ADDRESS
NCMDS	=8
CALLE	LDA #'C         ;SET A=C TO INDICATE
	STA TMPC
	BNE B3          ;CALL ENTRY, THEN JMP TO B3
BRKE	JSR CLRCH       ;CLR CHANNELS
	LDA #'B
	STA TMPC
	CLD
	LSR A           ;SET CY FOR PC CORRECTION
	PLA
	STA YR          ;SAVE Y
	PLA
	STA XR          ;AND X
	PLA
	STA ACC         ;AND ACCUMULATOR
	PLA
	STA FLGS        ;AND FLAGS
B3	PLA
	ADC #$FF        ;CY SET TO PC-1 FOR BREAK
	STA PCL
	PLA
	ADC #$FF
	STA PCH
	LDA CINV
	STA INVL
	LDA CINV+1
	STA INVH
	TSX
	STX SP          ;SAVE ORIGINAL SP
	CLI             ;CLBAR INTS
B5	JSR CRLF
	LDX TMPC        ;SET X EQUAL TO B OR C
	LDA #'*
	JSR WRTWO
	LDA #'R         ;SET FOR R DISPLAY TO
;                      PERMIT IMMEDIATE
;                      ALTER FOLLOWING
;                      BREAKPOINT
	BNE S0
STRT	LDA #2          ;NEXT COMMAND FROM USER
	STA TXTPTR
	LDA #0
	STA WRAP        ;CLEAR ADR WRAPZAROUND FLAG
	LDX #CR
	LDA #'.         ;TYPE A PROMPTING '. '
	JSR WRTWO
ST1	JSR RDOC        ;READ COMMAND. CHARACTER
;                      IS RETURNED IN A
	CMP #'.         ;IGNORE PROMPTING '. '
	BEQ ST1
	CMP #$20        ;IGNORE SPACES
	BEQ ST1
S0	LDX #NCMDS-1    ;LOOKUP COMMAND
S1	CMP CMDS,X
	BNE S2
	STX SAVX        ;SAVE CURRENT COMMAND INDEX
;INDIRECT JMP FROM TABLE BY
; PUSHING TARGET ADDRESS-1
;  THEN RTS
	LDA ADRH,X
	PHA
	LDA ADRL,X
	PHA
	RTS
S2	DEX
	BPL S1          ;LOOP FOR ALL. COMMANDS
	JMP (USRCMD)
PUTP	LDA TMP0        ;MOVE TMP0 TO PCH,PCL
	STA PCL
	LDA TMP0+1
	STA PCH
	RTS
;
;DISPLAY MEM SUBR. SET AR=NUMBER
;OF MEMORY BYTES DISPLAYED.
;TMP0=ADR OF MEM DISPLAYED
;
DM	STA TMPC
	LDY #0
DM1	JSR SPACE       ;WR N BYTES
	LDA (TMP0),Y    ;(TMP0)=ADR
	JSR WROB
	JSR INCTMP
	DEC TMPC
	BNE DM1
	RTS
;READ AND STORE BYTE.
;NO STORE IF SPACE OR TMPC = O.
BYTE	JSR RDOB        ;CHAR IN A, CY=O0 IF SP
	BCC BY3         ;SPACE
	LDX #0          ;STORE BYTE
	STA (TMP0,X)
	CMP (TMP0,X)    ;TEST FOR VALID WRITE (RAM)
	BEQ BY3
	PLA             ;ERROR: CLEAR JSR ADR IN STACK
	PLA
	JMP ERROPR
BY3	JSR INCTMP      ;GO INC TMPO ADR
	DEC TMPC
	RTS
SETR	LDA #<FLGS      ;SET TO ACCESS REGS
	STA TMP0
	LDA #>FLGS
	STA TMP0+1
	LDA #5
	RTS
SPAC2	JSR SPACE
SPACE	LDA #$20
	.BYT $2C
CRLF	LDA #$D
	JMP BSOUT
;INCREMENT (TMP0,TMP0+1) BY 1
INCTMP	INC TMP0        ;LOW BYTE
	BNE SETWR
	INC TMP0+1      ;HIGH BYTE
	BNE SETWR
	INC WRAP
SETWR	RTS
.PAG 'COMMAND & ADDR TABLE'
CMDS	.BYT ':'        ;MODIFY MEMORY
	.BYT ';'        ;ALTER REGISTERS
	.BYT 'R'        ;DIGPLAY REGS
	.BYT 'M'        ;DISPLAY MEMORY
	.BYT 'G'        ;START EXECUTION
	.BYT 'X'        ;WARM START BASIC
	.BYT 'L'        ;LOAD MEMORY
	.BYT 'S'        ;SAVE MEMORY
ADRH	.BYT >ZZ1
	.BYT >ZZ2
	.BYT >ZZ3
	.BYT >ZZ4
	.BYT >ZZ5
	.BYT >ZZ6
	.BYT >ZZ7
	.BYT >ZZ8
ADRL	.BYT <ZZ1
	.BYT <ZZ2
	.BYT <ZZ3
	.BYT <ZZ4
	.BYT <ZZ5
	.BYT <ZZ6
	.BYT <ZZ7
	.BYT <ZZ8
.PAG 'PET MONITOR 13.1'
REGK	.BYT CR,$20,$20,$20,$20 ;4 SPACES
	.BYT ' PC ',' IRQ ',' SR AC XR YR SP'
ALTRIT	TYA
	PHA
	JSR CRLF
	PLA
	LDX #'.
	JSR WRTWO
	JMP SPAC2
.SKI
DSPLYR	LDX #0
D2	LDA REGK,X
	JSR BSOUT
	INX
	CPX #29
	BNE D2
	LDY #';
	JSR ALTRIT
	LDA PCH
	JSR WROB
	LDA PCL
	JSR WROB
	JSR SPACE
	LDA INVH
	JSR WROB
	LDA INVL
	JSR WROB
	JSR SETR
	JSR DM          ;USE DM SUBR.
	BEQ BEQS1
DSPLYM	JSR RDOC
	JSR RDOA        ;READ START ADR
	BCC ERRS1       ;ERR IF NO SA
	JSR T2T2        ;SA TO TMP2
	JSR RDOC        ;SKIP DELIMITER
	JSR RDOA        ;READ END ADR
	BCC ERRS1       ;ERR IF NO EA
	JSR T2T2        ;SA TO TMP0, EA TO TMP2
DSP1	JSR STOP1       ;TEST FOR STOP KEY
	BEQ BEQS1
	LDX WRAP
	BNE BEQS1
	SEC             ;DOUBLE BYTE COMPARE
	LDA TMP2
	SBC TMP0
	LDA TMP2+1
	SBC TMP0+1
	BCC BEQS1       ;STOP IF EA LESS THAN SA
	LDY #':
	JSR ALTRIT
	JSR WROA
	LDA #8
	JSR DM          ;DIGPLAY 8, INCR TMPO
	BEQ DSP1
BEQS1	JMP STRT
ERRS1	JMP ERROPR
;ALTER REGISTERS
ALTR	JSR RDOB        ;SKIP 2 SPACES
	JSR RDOA        ;CY=0 IF SP
	BCC AL2         ;SPACE
	JSR PUTP        ;ALTER PC
AL2	JSR BASIN
	JSR RDOA
	BCC AL3
	LDA TMP0
	STA INVL
	LDA TMP0+1
	STA INVH
AL3	JSR SETR        ;SET TO ALTER R'S
	BNE A4
; ALTER MEMORY - READ ADR AND DATA
ALTM	JSR RDOB        ;SKIP 2 SPACES
	JSR RDOA        ;READ MEM ALTER ADR
	BCC ERRS1       ;CY=0, IF SPACE,ERR
	LDA #8          ;SET CNT = 8
A4	STA TMPC
A5	JSR RDOC
	JSR BYTE
	BNE A5
A9	BEQ BEQS1
GO	JSR BASIN
	CMP #$0D        ;IF CR, EXIT
	BEQ G1
	CMP #$20        ;1F NOT SPACE, ERR
	BNE ERRS1
	JSR RDOA
	BCC G1
	JSR PUTP
G1	LDX SP
	TXS             ;ORIG OR NEW SP VALUE TO SP
	SEI
	LDA INVH
	STA CINV+1
	LDA INVL
	STA CINV
	LDA PCH
	PHA
	LDA PCL
	PHA
	LDA FLGS
	PHA
	LDA ACC
	LDX XR
	LDY YR
	RTI
EXIT	LDX SP
	TXS
	JMP READY       ;EXIT TO BASIC WARM START
ERRL	JMP ERROPR
ZZZ1	=SAVNAM         ;PLACE TO PUT NAME
LD	LDY #1
	STY FA          ;DEFAULT DEVICE #1
	DEY
	STY FNLEN
	STY SATUS       ;CLEAR STATUS ON LOAD
	STY VERCK
	LDA #>ZZZ1      ;PLACE TO STORE NAME
	STA FNADR+1
	LDA #<ZZZ1
	STA FNADR
L1	JSR BASIN
	CMP #' 
	BEQ L1          ;SPAN BLANKS
	CMP #CR
	BEQ L5          ;DEFAULT TO LOAD
	CMP #'"
L2	BNE ERRL        ;FILE NAME MUST BE NEXT
L3	JSR BASIN
	CMP #'"
	BEQ L8          ;END OF NAME
	CMP #CR         ;DEFAULT A LOAD
	BEQ L5
	STA (FNADR)Y
	INC FNLEN
	INY
	CPY #16
L4	BEQ ERRL        ;FILE NAME TOO LONG
	BNE L3
L5	LDA SAVX
	CMP #6
L6	BNE L2          ;NOT A LOAD
	JSR LD15
	JSR TWAIT
	LDA SATUS
	AND #SPERR
L7	BNE L6          ;LOAD ERROR
	JMP STRT
L8	JSR BASIN
	CMP #CR
	BEQ L5          ;DEFUALT LOAD
	CMP #',
L9	BNE L7          ;BAD SYNTAX
	JSR RDOB
	AND #$F
L10	BEQ L4          ;DEVICE 0
	CMP #3
L11	BEQ L10         ;DEVICE 3
	STA FA
	JSR BASIN
	CMP #CR
	BEQ L5          ;DEFAULT LOAD
	CMP #',
L12	BNE L9          ;BAD SYNTAX
	JSR RDOA
	JSR T2T2
	JSR BASIN
	CMP #',
L13	BNE L12         ;MISSING END ADDR
	JSR RDOA
	LDA TMP0
	STA EAL
	LDA TMP0+1
	STA EAH
	JSR T2T2
L20	JSR BASIN
	CMP #$20
	BEQ L20
	CMP #CR
L14	BNE L13         ;MISSING CR AT END
	LDA SAVX
	CMP #7
	BNE L14
	JSR SV5
	JMP STRT
ZZ1=ALTM-1
ZZ2=ALTR-1
ZZ3=DSPLYR-1
ZZ4=DSPLYM-1
ZZ5=GO-1
ZZ6=EXIT-1
ZZ7=LD-1
ZZ8=LD-1
.FIL UTILIT
