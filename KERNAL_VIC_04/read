.PAGE 'CASSETTE READ'
; VARIABLES USED IN CASSETTE READ ROUTINES
;
;  REZ - COUNTS ZEROS (IF Z THEN CORRECT # OF DIPOLES)
;  RER - FLAGS ERRORS (IF Z THEN NO ERROR)
;  DIFF - USED TO PRESERVE SYNO (OUTSIDE OF BIT ROUTINES)
;  SYNO - FLAGS IF WE HAVE BLOCK SYNC (16 ZERO DIPOLES)
;  SNSW1 - FLAGS IF WE HAVE BYTE SYNC (A LONGLONG)
;  DATA - HOLDS MOST RECENT DIPOLE BIT VALUE
;  MYCH - HOLDS INPUT BYTE BEING BUILT
;  FIRT - USED TO INDICATE WHICH HALF OF DIPOLE WE'RE IN
;  SVXT - TEMP USED TO ADJUST SOFTWARE SERVO
;  TEMP - USED TO HOLD DIPOLE TIME DURING TYPE CALCULATIONS
;  PRTY - HOLDS CURRENT CALCULATED PARITY BIT
;  PRP - HAS COMBINED ERROR VALUES FROM BIT ROUTINES
;  FSBLK - INDICATE WHICH BLOCK WE'RE LOOKING AT (0 TO EXIT)
;  SHCNL - HOLDS FSBLK, USED TO DIRECT ROUTINES, BECAUSE OF EXIT CASE
;  RDFLG - HOLDS FUNCTION MODE
;     MI - WAITING FOR BLOCK SYNC
;     VS - IN DATA BLOCK READING DATA
;     NE - WAITING FOR BYTE SYNC
;  SAL - INDIRECT TO DATA STORAGE AREA
;  SHCNH - LEFT OVER FROM DEBUGGING
;  BAD - STORAGE SPACE FOR BAD READ LOCATIONS (BOTTOM OF STACK)
;  PTR1 - COUNT OF READ LOCATIONS IN ERROR (POINTER INTO BAD, MAX 61)
;  PTR2 - COUNT OF RE-READ LOCATIONS (POINTER INTO BAD, DURING RE-READ)
;  VERCHK - VERIFY OR LOAD FLAG (Z - LOADING)
;
.PAG 'CASSETTE READ'
READ	LDX D2T2H       ;GET TIME SINCE LAST INTERRUPT
	LDY #$FF        ;COMPUTE COUNTER DIFFERENCE
	TYA
	SBC D2T2L
	CPX D2T2H       ;CHECK FOR TIMER HIGH ROLLOVER...
	BNE READ        ;...YES THEN RECOMPUTE
	STX TEMP
	TAX
	STY D2T2L       ;RELOAD TIMER2 (COUNT DOWN FROM $FFFF)
	STY D2T2H
	TYA
	SBC TEMP        ;CALCULATE HIGH
	STX TEMP
	LSR A           ;MOVE TWO BITS FROM HIGH TO TEMP
	ROR TEMP
	LSR A
	ROR TEMP
	LDA CMP0        ;CALC MIN PULSE VALUE
	CLC
	ADC #60
	BIT D2ORAH      ;CLEAR READ INTERRUPT FLAG
	CMP TEMP        ;IF PULSE LESS THAN MIN...
	BCS RDBK        ;...THEN IGNORE AS NOISE
	LDX DPSW        ;CHECK IF LAST BIT...
	BEQ RJDJ        ;...NO THEN CONTINUE
	JMP RADJ        ;...YES THEN GO FINISH BYTE
.SKI 2
RJDJ	LDX PCNTR       ;IF 9 BITS READ...
	BMI JRAD2       ;... THEN GOTO ENDING
	LDX #0          ;SET BIT VALUE TO ZERO
	ADC #48         ;ADD UP TO HALF WAY BETWEEN...
	ADC CMP0        ;...SHORT PULSE AND SYNC PULSE
	CMP TEMP        ;CHECK FOR SHORT...
	BCS RADX2       ;...YES IT'S A SHORT
	INX             ;SET BIT VALUE TO ONE
	ADC #38         ;MOVE TO MIDDLE OF HIGH
	ADC CMP0
	CMP TEMP        ;CHECK FOR ONE...
	BCS RADL        ;...YES IT'S A ONE
	ADC #44         ;MOVE TO LONGLONG
	ADC CMP0
	CMP TEMP        ;CHECK FOR LONGLONG...
	BCC SRER        ;...GREATER THAN IS ERROR
JRAD2	JMP RAD2        ;...IT'S A LONGLONG
.SKI 2
SRER	LDA SNSW1       ;IF NOT SYNCRONIZED...
	BEQ RDBK        ;...THEN NO ERROR
	STA RER         ;...ELSE FLAG RER
	BNE RDBK        ;JMP
.SKI 2
RADX2	INC REZ         ;COUNT REZ UP ON ZEROS
	BCS RAD5        ;JMP
RADL	DEC REZ         ;COUNT REZ DOWN ON ONES
RAD5	SEC             ;CALC ACTUAL VALUE FOR COMPARE STORE
	SBC #19
	SBC TEMP        ;SUBTRACT INPUT VALUE FROM CONSTANT...
	ADC SVXT        ;...ADD DIFFERENCE TO TEMP STORAGE...
	STA SVXT        ;...USED LATER TO ADJUST SOFT SERVO
	LDA FIRT        ;FLIP DIPOLE FLAG
	EOR #1
	STA FIRT
	BEQ RAD3        ;SECOND HALF OF DIPOLE
	STX DATA        ;FIRST HALF SO STORE ITS VALUE
.SKI 3
RDBK	LDA SNSW1       ;IF NO BYTE START...
	BEQ RADBK       ;...THEN RETURN
	BIT D2IFR       ;CHECK TO SEE IF TIMER1 IRQD US...
	BVC RADBK       ;...NO, SO EXIT
	LDA #0          ;...YES, SET DIPOLE FLAG FOR FIRST HALF
	STA FIRT
	LDA PCNTR       ;CHECK WHERE WE ARE IN BYTE...
	BPL RAD4        ;...DOING DATA
	BMI JRAD2       ;...PROCESS PARITY
.SKI 2
RADP	LDX #166        ;SET UP FOR LONGLONG TIMEOUT
	JSR STT1
	LDA PRTY        ;IF PARITY NOT EVEN...
	BNE SRER        ;...THEN GO SET ERROR
RADBK	JMP PREND       ;GO RESTORE REGS AND RTI
.SKI 3
RAD3	LDA SVXT        ;ADJUST THE SOFTWARE SERVO (CMP0)
	BEQ ROUT1       ;NO ADJUST
	BMI ROUT2       ;ADJUST FOR MORE BASE TIME
	DEC CMP0        ;ADJUST FOR LESS BASE TIME
	.BYT $2C        ;SKIP TWO BYTES
ROUT2	INC CMP0
ROUT1	LDA #0          ;CLEAR DIFFERENCE VALUE
	STA SVXT
;CHECK FOR CONSECUTIVE LIKE VALUES IN DIPOLE...
	CPX DATA
	BNE RAD4        ;...NO, GO PROCESS INFO
	TXA             ;...YES SO CHECK THE VALUES...
	BNE SRER        ;IF THEY WERE ONES THEN  ERROR
; CONSECUTIVE ZEROS
	LDA REZ         ;...CHECK HOW MANY ZEROS HAVE HAPPENED
	BMI RDBK        ;...IF MANY DON'T CHECK
	CMP #16         ;... DO WE HAVE 16 YET?...
	BCC RDBK        ;....NO SO CONTINUE
	STA SYNO        ;....YES SO FLAG SYNO (BETWEEN BLOCKS)
	BCS RDBK        ;JMP
.SKI 3
RAD4	TXA             ;MOVE READ DATA TO .A
	EOR PRTY        ;CALCULATE PARITY
	STA PRTY
	LDA SNSW1       ;REAL DATA?...
	BEQ RADBK       ;...NO SO FORGET BY EXITING
	DEC PCNTR       ;DEC BIT COUNT
	BMI RADP        ;IF MINUS THEN  TIME FOR PARITY
	LSR DATA        ;SHIFT BIT FROM DATA...
	ROR MYCH        ;...INTO BYTE STORAGE (MYCH) BUFFER
	LDX #218        ;SET UP FOR NEXT DIPOLE
	JSR STT1
	JMP PREND       ;RESTORE REGS AND RTI
.SKI 3
; RAD2 - LONGLONG HANDLER (COULD BE A LONG ONE)
RAD2	LDA SYNO        ;HAVE WE GOTTEN BLOCK SYNC...
	BEQ RAD2Y       ;...NO
	LDA SNSW1       ;CHECK IF WE'VE HAD A REAL BYTE START...
	BEQ RAD2X       ;...NO
RAD2Y	LDA PCNTR       ;ARE WE AT END OF BYTE...
	BPL RADL        ;...NO SO TREAT IT AS A LONG ONE READ
.SKI 2
RAD2X	LSR TEMP        ;ADJUST TIMEOUT FOR...
	LDA #147        ;...LONGLONG PULSE VALUE
	SEC
	SBC TEMP
	ADC CMP0
	ASL A
	TAX             ;AND SET TIMEOUT FOR LAST BIT
	JSR STT1
	INC DPSW        ;SET BIT THROW AWAY FLAG
	LDA SNSW1       ;IF BYTE SYNCRONIZED....
	BNE RADQ2       ;...THEN SKIP TO PASS CHAR
	LDA SYNO        ;THROWS OUT DATA UNTILL BLOCK SYNC...
	BEQ RDBK2       ;...NO BLOCK SYNC
	STA RER         ;FLAG DATA AS ERROR
	LDA #0          ;KILL 16 SYNC FLAG
	STA SYNO
	LDA #$C0        ;SET UP FOR TIMER1 INTERRUPTS
	STA D2IER
	STA SNSW1       ;FLAG THAT WE HAVE BYTE SYNCRONIZED
;
RADQ2	LDA SYNO        ;SAVE SYNO STATUS
	STA DIFF
	BEQ RADK        ;NO BLOCK SYNC, NO BYTE LOOKING
	LDA #0          ;TURN OFF BYTE SYNC SWITCH
	STA SNSW1
	LDA #$40        ;DISABLE TIMER1 INTERRUPTS
	STA D2IER
RADK	LDA MYCH        ;PASS CHARACTER TO BYTE ROUTINE
	STA OCHAR
	LDA RER         ;COMBINE ERROR VALUES WITH ZERO COUNT...
	ORA REZ
	STA PRP         ;...AND SAVE IN PRP
RDBK2	JMP PREND       ;GO BACK AND GET LAST BYTE
.SKI 2
RADJ	JSR NEWCH       ;FINISH BYTE, CLR FLAGS
	STA DPSW        ;CLEAR BIT THROW AWAY FLAG
	LDX #218        ;INITILIZE FOR NEXT DIPOLE
	JSR STT1
	LDA FSBLK       ;CHECK FOR LAST VALUE
	BEQ RD15
	STA SHCNL
.PAG 'BYTE HANDLER'
;*************************************************
;* BYTE HANDLER OF CASSETTE READ                 *
;*                                               *
;* THIS PORTION OF IN LINE CODE IS PASSED THE    *
;* BYTE ASSEMBLED FROM READING TAPE IN OCHAR.    *
;* RER IS SET IF THE BYTE READ IS IN ERROR.      *
;* REZ IS SET IF THE INTERRUPT PROGRAM IS READING*
;* ZEROS.  RDFLG TELLS US WHAT WE ARE DOING.     *
;* BIT 7 SAYS TO IGNORE BYTES UNTIL REZ IS SET   *
;* BIT 6 SAYS TO LOAD THE BYTE. OTHERWISE RDFLG  *
;* IS A COUNTDOWN AFTER SYNC.  IF VERCK IS SET   *
;* WE DO A COMPARE INSTEAD OF A STORE AND SET    *
;* STATUS.  FSBLK COUNTS THE TWO BLOCKS. PTR1 IS *
;* INDEX TO ERROR TABLE FOR PASS1.  PTR2 IS INDEX*
;* TO CORRECTION TABLE FOR PASS2.                *
;*************************************************
;
SPERR=16
CKERR=32
SBERR=4
LBERR=8
;
RD15	LDA #$F
;
	BIT RDFLG       ;TEST FUNCTION MODE
	BPL RD20        ;NOT WAITING FOR ZEROS
;
	LDA DIFF        ;ZEROS YET?
	BNE RD12        ;YES...WAIT FOR SYNC
	LDX FSBLK       ;IS PASS OVER?
	DEX             ;...IF FSBLK ZERO THEN NO ERROR (FIRST GOOD)
	BNE RD10        ;NO...
;
	LDA #LBERR
	JSR UDST        ;YES...LONG BLOCK ERROR
	BNE RD10        ;BRANCH ALWAYS
;
RD12	LDA #0
	STA RDFLG       ;NEW MODE IS WAIT FOR SYNC
RD10	JMP PREND       ;EXIT...DONE
;
RD20	BVS RD60        ;WE ARE LOADING
	BNE RD200       ;WE ARE SYNCING
;
	LDA DIFF        ;DO WE HAVE BLOCK SYNC...
	BNE RD10        ;...YES, EXIT
	LDA PRP         ;IF FIRST BYTE HAS ERROR...
	BNE RD10        ;...THEN SKIP (EXIT)
	LDA SHCNL       ;MOVE FSBLK TO CARRY...
	LSR A
	LDA OCHAR       ; SHOULD BE A HEADER COUNT CHAR
	BMI RD22        ;IF NEG THEN FIRSTBLOCK DATA
	BCC RD40        ;...EXPECTING FIRSTBLOCK DATA...YES
	CLC
RD22	BCS RD40        ;EXPECTING SECOND BLOCK?...YES
	AND #$F         ;MASK OFF HIGH STORE HEADER COUNT...
	STA RDFLG       ;...IN MODE FLAG (HAVE CORRECT BLOCK)
RD200	DEC RDFLG       ;WAIT UNTILL WE GET REAL DATA...
	BNE RD10        ;...9876543210 REAL
	LDA #$40        ;NEXT UP IS REAL DATA...
	STA RDFLG       ;...SET DATA MODE
	JSR RD300       ;GO SETUP ADDRESS POINTERS
	LDA #0          ;DEBUG CODE####################################
	STA SHCNH
	BEQ RD10        ;JMP TO CONTINUE
.SKI 2
RD40	LDA #$80        ;WE WANT TO...
	STA RDFLG       ;IGNORE BYTES MODE
	BNE RD10        ;JMP
.SKI 2
RD60	LDA DIFF        ;CHECK FOR END OF BLOCK...
	BEQ RD70        ;...OKAY
;
	LDA #SBERR      ;SHORT BLOCK ERROR
	JSR UDST
	LDA #0          ;FORCE RDFLG FOR AN END
	JMP RD161
.SKI 2
RD70	JSR CMPSTE      ;CHECK FOR END OF STORAGE AREA
	BCC *+5         ;NOT DONE YET
	JMP RD160
	LDX SHCNL       ;CHECK WHICH PASS...
	DEX
	BEQ RD58        ;...SECOND PASS
	LDA VERCK       ;CHECK IF LOAD OR VERIFY...
	BEQ RD80        ;...LOADING
	LDY #0          ;...JUST VERIFYING
	LDA OCHAR
	CMP (SAL)Y      ;COMPARE WITH DATA IN PET
	BEQ RD80        ;...GOOD SO CONTINUE
	LDA #1          ;...BAD SO FLAG...
	STA PRP         ;...AS AN ERROR
.SKI 1
; STORE BAD LOCATIONS FOR SECOND PASS RE-TRY
RD80	LDA PRP         ;CHK FOR ERRORS...
	BEQ RD59        ;...NO ERRORS
	LDX #61         ;MAX ALLOWED IS 30
	CPX PTR1        ;ARE WE AT MAX?...
	BCC RD55        ;...YES, FLAG AS SECOND PASS ERROR
	LDX PTR1        ;GET INDEX INTO BAD...
	LDA SAH         ;...AND STORE THE BAD LOCATION
	STA BAD+1,X     ;...IN BAD TABLE
	LDA SAL
	STA BAD,X
	INX             ;ADVANCE POINTER TO NEXT
	INX
	STX PTR1
	JMP RD59        ;GO STORE CHARACTER
.SKI 2
; CHECK BAD TABLE FOR RE-TRY (SECOND PASS)
RD58	LDX PTR2        ;HAVE WE DONE ALL IN THE TABLE?...
	CPX PTR1
	BEQ RD90        ;...YES
	LDA SAL         ;SEE IF THIS IS NEXT IN THE TABLE...
	CMP BAD,X
	BNE RD90        ;...NO
	LDA SAH
	CMP BAD+1,X
	BNE RD90        ;...NO
	INC PTR2        ;WE FOUND NEXT ONE, SO ADVANCE POINTER
	INC PTR2
	LDA VERCK       ;DOING A LOAD OR VERIFY?...
	BEQ RD52        ;...LOADING
	LDA OCHAR       ;...VERIFYING, SO CHECK
	LDY #0
	CMP (SAL)Y
	BEQ RD90        ;...OKAY
	INY             ;MAKE .Y= 1
	STY PRP         ;FLAG IT AS AN ERROR
.SKI 2
RD52	LDA PRP         ;A SECOND PASS ERROR?...
	BEQ RD59        ;...NO
;SECOND PASS ERR
RD55	LDA #SPERR
	JSR UDST
	BNE RD90        ;JMP
.SKI 2
RD59	LDA VERCK       ;LOAD OR VERIFY?...
	BNE RD90        ;...VERIFY, DON'T STORE
	TAY             ;MAKE Y ZERO
	LDA OCHAR
	STA (SAL)Y      ;STORE CHARACTER
RD90	JSR INCSAL      ;INCREMENT ADDR.
	BNE RD180       ;BRANCH ALWAYS
.SKI 3
RD160	LDA #$80        ;SET MODE SKIP NEXT DATA
RD161	STA RDFLG
	LDX FSBLK       ;DEC FSBLK FOR NEXT PASS...
	DEX
	BMI RD167       ;WE ARE DONE...FSBLK=0
	STX FSBLK       ;...ELSE FSBLK=NEXT
RD167	DEC SHCNL       ;DEC PASS CALC...
	BEQ RD175       ;...ALL DONE
	LDA PTR1        ;CHECK FOR FIRST PASS ERRORS...
	BNE RD180       ;...YES SO CONTINUE
	STA FSBLK       ;CLEAR FSBLK IF NO ERRORS...
	BEQ RD180       ;JMP TO EXIT
.SKI 2
RD175	JSR TNIF        ;READ IT ALL...EXIT
	JSR RD300       ;RESTORE SAL & SAH
	LDY #0          ;SET SHCNH TO ZERO...
	STY SHCNH       ;...USED TO CALC PARITY BYTE
;
;COMPUTE PARITY OVER LOAD
;
VPRTY	LDA (SAL)Y      ;CALC BLOCK BCC
	EOR SHCNH
	STA SHCNH
	JSR INCSAL      ;INCREMENT ADDRESS
	JSR CMPSTE      ;TEST AGAINST END
	BCC VPRTY       ;NOT DONE YET...
	LDA SHCNH       ;CHECK FOR BCC CHAR MATCH...
	EOR OCHAR
	BEQ RD180       ;...YES, EXIT
;CHKSUM ERROR
	LDA #CKERR
	JSR UDST
RD180	JMP PREND
.SKI 4
RD300	LDA STAH        ; RESTORE STARTING ADDRESS...
	STA SAH         ;...POINTERS (SAH & SAL)
	LDA STAL
	STA SAL
	RTS
.SKI 4
NEWCH	LDA #8          ;SET UP FOR 8 BITS+PARITY
	STA PCNTR
	LDA #0          ;INITILIZE...
	STA FIRT        ;..DIPOLE COUNTER
	STA RER         ;..ERROR FLAG
	STA PRTY        ;..PARITY BIT
	STA REZ         ;..ZERO COUNT
	RTS             ;.A=0 ON RETURN
.END
; RSR 7/31/80 ADD COMMENTS
