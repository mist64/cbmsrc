.PAGE 'READ 01/18/83'
; VARIABLES USED IN CASSETTE READ ROUTINES
;
;  REZ - COUNTS ZEROS (IF Z THEN CORRECT # OF DIPOLES)
;  RER - FLAGS ERRORS (IF Z THEN NO ERROR)
;  DIFF - USED TO PRESERVE SYNO (OUTSIDE OF BIT ROUTINES)
;  SYNO - FLAGS IF WE HAVE BLOCK SYNC (16 ZERO DIPOLES)
;  SNSW1 - FLAGS IF WE HAVE BYTE SYNC (A LONGLONG)
;  CDATA - HOLDS MOST RECENT DIPOLE BIT VALUE
;  MYCH - HOLDS INPUT BYTE BEING BUILT
;  FIRT - USED TO INDICATE WHICH HALF OF DIPOLE WE'RE IN
;  DFLTO - TEMP USED TO ADJUST SOFTWARE SERVO
;  CTEMP - USED TO HOLD DIPOLE TIME DURING TYPE CALCULATIONS
;  PRTY - HOLDS CURRENT CALCULATED PARITY BIT
;  PRP - HAS COMBINED ERROR VALUES FROM BIT ROUTINES
;  FSBLK - INDICATE WHICH BLOCK WE'RE LOOKING AT (0 TO EXIT)
;  SHCNL - HOLDS FSBLK, USED TO DIRECT ROUTINES, BECAUSE OF EXIT CASE
;  RDFLG - HOLDS FUNCTION MODE
;     MI - WAITING FOR BLOCK SYNC
;     VS - IN DATA BLOCK READING DATA
;     NE - WAITING FOR BYTE SYNC
;  SAL - INDIRECT TO DATA STORAGE AREA
;  SHCNH - LEFT OVER FROM DEBUGGING
;  BAD - STORAGE SPACE FOR BAD READ LOCATIONS (BOTTOM OF STACK)
;  PTR1 - COUNT OF READ LOCATIONS IN ERROR (POINTER INTO BAD, MAX 61)
;  PTR2 - COUNT OF RE-READ LOCATIONS (POINTER INTO BAD, DURING RE-READ)
;  VERCHK - VERIFY OR LOAD FLAG (Z - LOADING)
;  CMP0 - SOFTWARE SERVO (+/- ADJUST TO TIME CALCS)
;  DPSW - IF NZ THEN EXPECTING LL/L COMBINATION THAT ENDS A BYTE
;  PCNTR - COUNTS DOWN FROM 8-0 FOR DATA THEN TO FF FOR PARITY
;  FLAGT1 - HOLD INDICATIOR (NZ - NO T1IRQ YET) FOR T1IRQ
;  KIKA26 - HOLDS OLD D1ICR AFTER CLEAR ON READ
;
.PAG 'CASSETTE READ'
READ	LDX CIA+TBHI    ;GET TIME SINCE LAST INTERRUPT
	LDY #$FF        ;COMPUTE COUNTER DIFFERENCE
	TYA
	SBC CIA+TBLO
	CPX CIA+TBHI    ;CHECK FOR TIMER HIGH ROLLOVER...
	BNE READ        ;...YES THEN RECOMPUTE
	STX CTEMP
	TAX
;STY CIA+TBLO ;RELOAD TIMER2 (COUNT DOWN FROM $FFFF)
;STY CIA+TBHI
;
;FORCE TIMER AND CLEAR INTERRUPT
;
	LDA #$19        ;ENABLE TIMER
	STA CIA+CRB
	INC TPI1+AIR
	LDA CIA+ICR     ;GET ACTUAL INTERRUPT
	STA DFLTN       ;SAVE IT IN THE DFLTN (****TEMP****)
;
	TYA
	SBC CTEMP       ;CALCULATE HIGH
	STX CTEMP
	LSR A           ;MOVE TWO BITS FROM HIGH TO CTEMP
	ROR CTEMP
	LSR A
	ROR CTEMP
	.IFE SYSTEM <
	LSR A           ;DIVIDE BY 2 FOR 2MHZ MACHINE
	ROR CTEMP
>
	.IFN SYSTEM <
;NOP
;NOP
;NOP
;NOP
>
	LDA CMP0        ;CALC MIN PULSE VALUE
	CLC
	ADC #60
	CMP CTEMP       ;IF PULSE LESS THAN MIN...
	BCS RDBK        ;...THEN IGNORE AS NOISE
	LDX DPSW        ;CHECK IF LAST BIT...
	BEQ RJDJ        ;...NO THEN CONTINUE
	JMP RADJ        ;...YES THEN GO FINISH BYTE
.SKI 2
RJDJ	LDX PCNTR       ;IF 9 BITS READ...
	BMI JRAD2       ;... THEN GOTO ENDING
	LDX #0          ;SET BIT VALUE TO ZERO
	ADC #48         ;ADD UP TO HALF WAY BETWEEN...
	ADC CMP0        ;...SHORT PULSE AND SYNC PULSE
	CMP CTEMP       ;CHECK FOR SHORT...
	BCS RADX2       ;...YES IT'S A SHORT
	INX             ;SET BIT VALUE TO ONE
	ADC #38         ;MOVE TO MIDDLE OF HIGH
	ADC CMP0
	CMP CTEMP       ;CHECK FOR ONE...
	BCS RADL        ;...YES IT'S A ONE
	ADC #44         ;MOVE TO LONGLONG
	ADC CMP0
	CMP CTEMP       ;CHECK FOR LONGLONG...
	BCC SRER        ;...GREATER THAN IS ERROR
JRAD2	JMP RAD2        ;...IT'S A LONGLONG
.SKI 2
SRER	LDA SNSW1       ;IF NOT SYNCRONIZED...
	BEQ RDBK        ;...THEN NO ERROR
	STA RER         ;...ELSE FLAG RER
	BNE RDBK        ;JMP
.SKI 2
RADX2	INC REZ         ;COUNT REZ UP ON ZEROS
	BCS RAD5        ;JMP
RADL	DEC REZ         ;COUNT REZ DOWN ON ONES
RAD5	SEC             ;CALC ACTUAL VALUE FOR COMPARE STORE
	SBC #19
	SBC CTEMP       ;SUBTRACT INPUT VALUE FROM CONSTANT...
	ADC DFLTO       ;...ADD DIFFERENCE TO TEMP STORAGE...
	STA DFLTO       ;...USED LATER TO ADJUST SOFT SERVO
	LDA FIRT        ;FLIP DIPOLE FLAG
	EOR #1
	STA FIRT
	BEQ RAD3        ;SECOND HALF OF DIPOLE
	STX CDATA       ;FIRST HALF SO STORE ITS VALUE
.SKI 3
RDBK	LDA SNSW1       ;IF NO BYTE START...
	BEQ RADBK       ;...THEN RETURN
	LDA DFLTN       ;CHECK TO SEE IF TIMER1 IRQD US...
	AND #$01
	BNE RADKX       ;YES...
	LDA FLAGT1      ;IF NO...CHECK FOR OLD T1IRQ
	BNE RADBK       ;NONE...SO EXIT
RADKX	LDA #0          ; SET DIPOLE FLAG FOR FIRST HALF
	STA FIRT
	STA FLAGT1      ;SET T1IRQ FLAG
	LDA PCNTR       ;CHECK WHERE WE ARE IN BYTE...
	BPL RAD4        ;...DOING DATA
	BMI JRAD2       ;...PROCESS PARITY
.SKI 2
RADP	LDX #166        ;SET UP FOR LONGLONG TIMEOUT
	JSR STT1
	LDA PRTY        ;IF PARITY NOT EVEN...
	BNE SRER        ;...THEN GO SET ERROR
RADBK	JMP PREND       ;GO RESTORE REGS AND RTI
.SKI 3
RAD3	LDA DFLTO       ;ADJUST THE SOFTWARE SERVO (CMP0)
	BEQ ROUTA       ;NO ADJUST
	BMI ROUT2       ;ADJUST FOR MORE BASE TIME
	DEC CMP0        ;ADJUST FOR LESS BASE TIME
	JMP ROUTA
ROUT2	INC CMP0
ROUTA	LDA #0          ;CLEAR DIFFERENCE VALUE
	STA DFLTO
;CHECK FOR CONSECUTIVE LIKE VALUES IN DIPOLE...
	CPX CDATA
	BNE RAD4        ;...NO, GO PROCESS INFO
	TXA             ;...YES SO CHECK THE VALUES...
	BNE SRER        ;IF THEY WERE ONES THEN  ERROR
; CONSECUTIVE ZEROS
	LDA REZ         ;...CHECK HOW MANY ZEROS HAVE HAPPENED
	BMI RDBK        ;...IF MANY DON'T CHECK
	CMP #16         ;... DO WE HAVE 16 YET?...
	BCC RDBK        ;....NO SO CONTINUE
	STA SYNO        ;....YES SO FLAG SYNO (BETWEEN BLOCKS)
	BCS RDBK        ;JMP
.SKI 3
RAD4	TXA             ;MOVE READ DATA TO .A
	EOR PRTY        ;CALCULATE PARITY
	STA PRTY
	LDA SNSW1       ;REAL DATA?...
	BEQ RADBK       ;...NO SO FORGET BY EXITING
	DEC PCNTR       ;DEC BIT COUNT
	BMI RADP        ;IF MINUS THEN  TIME FOR PARITY
	LSR CDATA       ;SHIFT BIT FROM DATA...
	ROR MYCH        ;...INTO BYTE STORAGE (MYCH) BUFFER
	LDX #218        ;SET UP FOR NEXT DIPOLE
	JSR STT1
	JMP PREND       ;RESTORE REGS AND RTI
.SKI 3
; RAD2 - LONGLONG HANDLER (COULD BE A LONG ONE)
RAD2	LDA SYNO        ;HAVE WE GOTTEN BLOCK SYNC...
	BEQ RAD2Y       ;...NO
	LDA SNSW1       ;CHECK IF WE'VE HAD A REAL BYTE START...
	BEQ RAD2X       ;...NO
RAD2Y	LDA PCNTR       ;ARE WE AT END OF BYTE...
	BMI RAD2X       ;...YES SO IT'S EXPECTED
	JMP RADL        ;...NO SO TREAT IT AS A LONG ONE READ
.SKI 2
RAD2X	LSR CTEMP       ;ADJUST TIMEOUT FOR...
	LDA #147        ;...LONGLONG PULSE VALUE
	SEC
	SBC CTEMP
	ADC CMP0
	ASL A
	TAX             ;AND SET TIMEOUT FOR LAST BIT
	JSR STT1
	INC DPSW        ;SET BIT THROW AWAY FLAG
	LDA SNSW1       ;IF BYTE SYNCRONIZED....
	BNE RADQ2       ;...THEN SKIP TO PASS CHAR
	LDA SYNO        ;THROWS OUT DATA UNTILL BLOCK SYNC...
	BEQ RDBK2       ;...NO BLOCK SYNC
	STA RER         ;FLAG DATA AS ERROR
	LDA #0          ;KILL 16 SYNC FLAG
	STA SYNO
;
	LDA #$81        ;ENABLE T1IRQ
	STA CIA+ICR
;
	STA SNSW1       ;FLAG THAT WE HAVE BYTE SYNCRONIZED
;
RADQ2	LDA SYNO        ;SAVE SYNO STATUS
	STA DIFF
	BEQ RADK        ;NO BLOCK SYNC, NO BYTE LOOKING
	LDA #0          ;TURN OFF BYTE SYNC SWITCH
	STA SNSW1
;
	LDA #$01        ;DIS-ABLE TA IRQ
	STA CIA+ICR
;
RADK	LDA MYCH        ;PASS CHARACTER TO BYTE ROUTINE
	STA OCHAR
	LDA RER         ;COMBINE ERROR VALUES WITH ZERO COUNT...
	ORA REZ
	STA PRP         ;...AND SAVE IN PRP
RDBK2	JMP PREND       ;GO BACK AND GET LAST BYTE
.SKI 2
RADJ	JSR NEWCH       ;FINISH BYTE, CLR FLAGS
	STA DPSW        ;CLEAR BIT THROW AWAY FLAG
	LDX #218        ;INITILIZE FOR NEXT DIPOLE
	JSR STT1
	LDA FSBLK       ;CHECK FOR LAST VALUE
	BEQ RD15
	STA SHCNL
.PAG 'BYTE HANDLER'
;*************************************************
;* BYTE HANDLER OF CASSETTE READ                 *
;*                                               *
;* THIS PORTION OF IN LINE CODE IS PASSED THE    *
;* BYTE ASSEMBLED FROM READING TAPE IN OCHAR.    *
;* RER IS SET IF THE BYTE READ IS IN ERROR.      *
;* REZ IS SET IF THE INTERRUPT PROGRAM IS READING*
;* ZEROS.  RDFLG TELLS US WHAT WE ARE DOING.     *
;* BIT 7 SAYS TO IGNORE BYTES UNTIL REZ IS SET   *
;* BIT 6 SAYS TO LOAD THE BYTE. OTHERWISE RDFLG  *
;* IS A COUNTDOWN AFTER SYNC.  IF VERCK IS SET   *
;* WE DO A COMPARE INSTEAD OF A STORE AND SET    *
;* STATUS.  FSBLK COUNTS THE TWO BLOCKS. PTR1 IS *
;* INDEX TO ERROR TABLE FOR PASS1.  PTR2 IS INDEX*
;* TO CORRECTION TABLE FOR PASS2.                *
;*************************************************
;
SPERR=16
CKERR=32
SBERR=4
LBERR=8
;
RD15	LDA #$F
;
	BIT RDFLG       ;TEST FUNCTION MODE
	BPL RD20        ;NOT WAITING FOR ZEROS
;
	LDA DIFF        ;ZEROS YET?
	BNE RD12        ;YES...WAIT FOR SYNC
	LDX FSBLK       ;IS PASS OVER?
	DEX             ;...IF FSBLK ZERO THEN NO ERROR (FIRST GOOD)
	BNE RD10        ;NO...
;
	LDA #LBERR
	JSR UDST        ;YES...LONG BLOCK ERROR
	BNE RD10        ;BRANCH ALWAYS
;
RD12	LDA #0
	STA RDFLG       ;NEW MODE IS WAIT FOR SYNC
RD10	JMP PREND       ;EXIT...DONE
;
RD20	BVS RD60        ;WE ARE LOADING
	BNE RD200       ;WE ARE SYNCING
;
	LDA DIFF        ;DO WE HAVE BLOCK SYNC...
	BNE RD10        ;...YES, EXIT
	LDA PRP         ;IF FIRST BYTE HAS ERROR...
	BNE RD10        ;...THEN SKIP (EXIT)
	LDA SHCNL       ;MOVE FSBLK TO CARRY...
	LSR A
	LDA OCHAR       ; SHOULD BE A HEADER COUNT CHAR
	BMI RD22        ;IF NEG THEN FIRSTBLOCK DATA
	BCC RD40        ;...EXPECTING FIRSTBLOCK DATA...YES
	CLC
RD22	BCS RD40        ;EXPECTING SECOND BLOCK?...YES
	AND #$F         ;MASK OFF HIGH STORE HEADER COUNT...
	STA RDFLG       ;...IN MODE FLAG (HAVE CORRECT BLOCK)
RD200	DEC RDFLG       ;WAIT UNTILL WE GET REAL DATA...
	BNE RD10        ;...9876543210 REAL
	LDA #$40        ;NEXT UP IS REAL DATA...
	STA RDFLG       ;...SET DATA MODE
	JSR RD300       ;GO SETUP ADDRESS POINTERS
;LDA #0 ;DEBUG CODE##################################################
;STA SHCNH
	JMP RD10        ;JMP TO CONTINUE
.SKI 2
RD40	LDA #$80        ;WE WANT TO...
	STA RDFLG       ;IGNORE BYTES MODE
	BNE RD10        ;JMP
.SKI 2
RD60	LDA DIFF        ;CHECK FOR END OF BLOCK...
	BEQ RD70        ;...OKAY
;
	LDA #SBERR      ;SHORT BLOCK ERROR
	JSR UDST
	LDA #0          ;FORCE RDFLG FOR AN END
	BEQ RD161       ;JUMP
.SKI 2
RD70	JSR CMPSTE      ;CHECK FOR END OF STORAGE AREA
	BCS RD160       ;...DONE
	LDX SHCNL       ;CHECK WHICH PASS...
	DEX
	BEQ RD58        ;...SECOND PASS
	LDA VERCK       ;CHECK IF LOAD OR VERIFY...
	BPL RD80        ;...LOADING
	LDY #0          ;...JUST VERIFYING
	LDA (SAL)Y      ;COMPARE WITH DATA IN PET
	CMP OCHAR
	BEQ RD80        ;...GOOD SO CONTINUE
	LDA #1          ;...BAD SO FLAG...
	STA PRP         ;...AS AN ERROR
.SKI 1
; STORE BAD LOCATIONS FOR SECOND PASS RE-TRY
RD80	LDA PRP         ;CHK FOR ERRORS...
	BEQ RD59        ;...NO ERRORS
	LDX #61         ;MAX ALLOWED IS 30
	CPX PTR1        ;ARE WE AT MAX?...
	BCC RD55        ;...YES, FLAG AS SECOND PASS ERROR
	LDX PTR1        ;GET INDEX INTO BAD...
	LDA SAH         ;...AND STORE THE BAD LOCATION
	STA BAD+1,X     ;...IN BAD TABLE
	LDA SAL
	STA BAD,X
	INX             ;ADVANCE POINTER TO NEXT
	INX
	STX PTR1
	JMP RD59        ;GO STORE CHARACTER
.SKI 2
; CHECK BAD TABLE FOR RE-TRY (SECOND PASS)
RD58	LDX PTR2        ;HAVE WE DONE ALL IN THE TABLE?...
	CPX PTR1
	BEQ RD90        ;...YES
	LDA SAL         ;SEE IF THIS IS NEXT IN THE TABLE...
	CMP BAD,X
	BNE RD90        ;...NO
	LDA SAH
	CMP BAD+1,X
	BNE RD90        ;...NO
	INC PTR2        ;WE FOUND NEXT ONE, SO ADVANCE POINTER
	INC PTR2
	LDA VERCK       ;DOING A LOAD OR VERIFY?...
	BPL RD52        ;...LOADING
	LDY #0
	LDA (SAL)Y
	CMP OCHAR       ;...VERIFYING, SO CHECK
	BEQ RD90        ;...OKAY
	INY             ;MAKE .Y= 1
	STY PRP         ;FLAG IT AS AN ERROR
.SKI 2
RD52	LDA PRP         ;A SECOND PASS ERROR?...
	BEQ RD59        ;...NO
;SECOND PASS ERR
RD55	LDA #SPERR
	JSR UDST
	BNE RD90        ;JMP
.SKI 2
RD59	LDA VERCK       ;LOAD OR VERIFY?...
	BMI RD90        ;...VERIFY, DON'T STORE
	LDY #0          ;MAKE Y ZERO
	LDA OCHAR
	STA (SAL)Y      ;STORE CHARACTER
RD90	JSR INCSAL      ;INCREMENT ADDR.
	JMP PREND       ;EXIT
.SKI 3
RD160	LDA #$80        ;SET MODE SKIP NEXT DATA
RD161	STA RDFLG
;
; MODIFY FOR 6526
;
	SEI             ;PROTECT CLEARING OF T1 INFORMATION
	LDX #$01
	STX CIA+ICR     ;CLEAR T1 ENABLE
	LDX CIA+ICR     ;CLEAR THE INTERRUPT
	LDX FSBLK       ;DEC FSBLK FOR NEXT PASS...
	DEX
	BMI RD167       ;WE ARE DONE...FSBLK=0
	STX FSBLK       ;...ELSE FSBLK=NEXT
RD167	DEC SHCNL       ;DEC PASS CALC...
	BEQ RD175       ;...ALL DONE
	LDA PTR1        ;CHECK FOR FIRST PASS ERRORS...
	BNE RD180       ;...YES SO CONTINUE
	STA FSBLK       ;CLEAR FSBLK IF NO ERRORS...
	BEQ RD180       ;JMP TO EXIT
.SKI 2
RD175	JSR TNIF        ;READ IT ALL...EXIT
	JSR RD300       ;RESTORE SAL & SAH
	LDY #0          ;SET SHCNH TO ZERO...
	STY SHCNH       ;...USED TO CALC PARITY BYTE
;
;COMPUTE PARITY OVER LOAD
;
VPRTY	LDA (SAL)Y      ;CALC BLOCK BCC
	EOR SHCNH
	STA SHCNH
	JSR INCSAL      ;INCREMENT ADDRESS
	JSR CMPSTE      ;TEST AGAINST END
	BCC VPRTY       ;NOT DONE YET...
	LDA SHCNH       ;CHECK FOR BCC CHAR MATCH...
	EOR OCHAR
	BEQ RD180       ;...YES, EXIT
;CHKSUM ERROR
	LDA #CKERR
	JSR UDST
RD180	JMP PREND
.SKI 4
NEWCH	LDA #8          ;SET UP FOR 8 BITS+PARITY
	STA PCNTR
	LDA #0          ;INITILIZE...
	STA FIRT        ;..DIPOLE COUNTER
	STA RER         ;..ERROR FLAG
	STA PRTY        ;..PARITY BIT
	STA REZ         ;..ZERO COUNT
	RTS             ;.A=0 ON RETURN
.END
